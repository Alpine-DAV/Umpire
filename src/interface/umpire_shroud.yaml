##############################################################################
# Copyright (c) 2018, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory
#
# Created by David Beckingsale, david@llnl.gov
# LLNL-CODE-747640
#
# All rights reserved.
#
# This file is part of Umpire.
#
# For details, see https://github.com/LLNL/Umpire
# Please also see the LICENSE file for MIT license.
##############################################################################

library: Umpire

options:
  F_module_per_class: False

format:
  C_prefix: umpire_

declarations:
- decl: namespace umpire
  declarations:
    - decl: class Allocator
      cxx_header: umpire/Allocator.hpp
      format:
        F_derived_name: UmpireAllocator

      declarations:
        - decl: void* allocate(size_t bytes)
        - decl: void deallocate (void* ptr)
        - decl: size_t getSize(void* ptr)
        - decl: size_t getHighWatermark()
        - decl: size_t getCurrentSize()
        # - decl: std::string getName()
        - decl: size_t getId()

        #
        # - decl: std::shared_ptr<umpire::strategy::AllocationStrategy> getAllocationStrategy()
        #

    - decl: class ResourceManager
      cxx_header: umpire/ResourceManager.hpp
      format:
        F_derived_name: UmpireResourceManager

      declarations:
        #
        # NOTE: Ideally, this would simply be "- decl: static ResourceManager& getInstance()"
        # But there seems to be a bug with the internal names produced by shroud for
        # constructors.  Namely, the internal name used is get_instance which conflicts
        # with what getInstance() gets translated to.  So, for the moment, we have to
        # specify a different name for the method and then specify the code to be run
        # that will call our internal C++ implementation of getInsance().
        #
        - decl: static ResourceManager& getinstance()
          format:
            C_code: |
              umpire::ResourceManager & SHCXX_rv = umpire::ResourceManager::getInstance();
              umpire_resourcemanager * SHC_rv = static_cast<umpire_resourcemanager *>(static_cast<void *>(&SHCXX_rv));
              return SHC_rv;

        - decl: void initialize()

        #
        # - decl: void finalize()
        # NOTE: Does not compile since implementation of finalize() is missing.
        #
        # - decl: std::vector<std::string> getAvailableAllocators()
        # NOTE: If needed, we will need to determine mechanism to return a vector
        #       object from a C interface.
        #

        - decl: Allocator* getAllocator(const std::string& name)
          format:
            C_code: |
              {C_pre_call}
              umpire::Allocator * SH_rv = new umpire::Allocator(SH_this->getAllocator(SH_name)); 
              umpire_allocator * XSH_rv = static_cast<umpire_allocator *>(static_cast<void *>(SH_rv)); 
              return XSH_rv;
 
        #
        # NOTE: This function is needed for Shroud only since object lifetime
        #       for C/FORTRAN callers needs to be explicit.
        #
        - decl: static void deleteAllocator(Allocator* alloc_obj)
          format:
            C_code: |
              {C_pre_call}
              delete SHCXX_alloc_obj;

        #
        # - decl: Allocator makeAllocator(const std::string& name, const std::string& strategy, util::AllocatorTraits traits, std::vector<Allocator> providers)
        # - decl: Allocator getAllocator(resource::MemoryResourceType resource_type)
        # - decl: Allocator getAllocator(void* ptr)
        #
        # - decl: void registerAllocation(void* ptr, util::AllocationRecord* record)
        # - decl: void deregisterAllocation(void* ptr)
        #

        - decl: void copy(void* src_ptr, void* dst_ptr, size_t size=0)
        - decl: void memset(void* ptr, int val, size_t length=0)
        - decl: void* reallocate(void* src_ptr, size_t size)
        - decl: void deallocate(void* ptr)
        - decl: size_t getSize(void* ptr)
